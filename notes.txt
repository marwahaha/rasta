# Syntax quote/unquote is working but untested
#
#
#     
#     
## unifying the reader
# move reader macro list from token-stack to the reader 
#   reader can intercept reader macros dynamically, so they don't get picked up as symbols
#   pass the reader macro to the Stack with the token.
# possibly reduce thenumber of characters allowable in Labels
# add a reader-macro stage that allows a token to modify the next form
#   can acheive most of this by allowing reader macros to substitute a new TokenStack class for the nested form
#   syntax-quote/unquote/unquote-splice will need to be fairly complex...
#     unquote/unquote-splice
#       both simply raise errors saying "you can't use these outside syntax-quoting"
#     syntax-quote macro `
#       causes the next node to be a SyntaxQuoteNode (subclass of node)
#       ~ reader macro of the nested token_stack is then changed to proc{|expr| Node.new(Label.new("unquote"), expr)}
#       # reader macro of the nested token_stack is then changed to proc{|expr| Node.new(Label.new("unquote-splice"), expr)}
#     SyntaxQuoteNode handles the unquote/unquote-splice forms
# make it impossible to add reader macros for two reasons:
#   the usefulness is limited since they can only be a single character long at the moment and almost all of the characters are in use
#   same arguments as with clojure... it'd make the code almost unreadable to a new person

# load standard library in rasta on boot

## Using rasta from ruby
# find a way to load stuff written in rasta into ruby
# this requires a method that imports ruby and rasta equivalently

## SOLVING SYMBOL CAPTURE
# make it imposible to use define outside the top scope
# check for un-resolvable Labels before adding a form to defs
# add a namespace property to Labels and qualify them when expanding macros

# use @ for namespacing ?

- can have objects in @head to __apply as message chains (like ioke)

- use modules to mix in __apply behaviours (eg. Chainable...) 

FIND A WAY TO IMPLEMENT SCOPED MONKEY PATCHING... That way you can redefine a type's call method, without having to lose the method sending aspect throughout your code base

- char literals

- add splats

- class special form

- improve error reporting... things should never go wrong silently.
  - when the input is syntactically invalid (eg. unmatching []{}() chars)
  - show short stack trace

- embed repl in vim
  - syntax highlighting
  - auto-indent
  - when cursor is on a given %, execute cmd sends only that node

let and loop/recur for local vars
(.. obj (method args) (method args))

add better support for sets?
  Set literal #{a s d f}
  Set#lispeval should return a proc that acts as a predicate

documentation within the language?
  meta-data?

to define a method on an object
(in obj ; instance-eval
  (defn method [a b]...
on a class
(in Array
  (defn ...

; where defn is defined as
defn = proc do |obj, method, fn|
  obj.define_method(method, fn)
end

need to add Object#define_method

when we want to execute a closure (ie. a special form/macro) in a specific context, we can pass receiver as the first arg to the proc, then the "in" special form does this...

in = proc do |obj, my_proc|
  obj.instance_eval{ my_proc.call(self)} can here, self refers to obj, since it's in an instance_eval
end

then when eval-ing normally (ie. in the root context) we pass the env in as self... that way, we always have full, explicit control over what self refers to in macros and special forms

macro hygeine?
  namespacing for everything stored in env?
    what about class names, constants and methods
  forced gensyms for locals (how?)
  substitute in special forms and macros (ie. things implemented as procs)

