## Tests
# write basic tests for the currently supported functionality

## unifying the reader
# add a reader-macro stage that allows a token to modify the next form
#   can acheive most of this by allowing reader macros to substitute a new TokenStack class for the nested form
#   syntax-macro special form for adding syntax macros to the Reader
#   w reader-macro for a list of words
#     should change the behaviour of the @nested token stack to call .print (or fetches the char for [:OTHER,...] tokens) on every token recieved and then return an array
#   syntax-quote/unquote/unquote-splice needs to be a very complex reader macro...
#   unquote/unquote-splice
#     both simply raise errors saying "you can't use these outside syntax-quoting"
#   syntax-quote macro `
#     causes the next node to be a SyntaxQuoteNode (subclass of node)
#     ~ reader macro of the nested token_stack is then changed to proc{|expr| Node.new(Label.new("unquote"), expr)}
#     ~~ reader macro of the nested token_stack is then changed to proc{|expr| Node.new(Label.new("unquote-splice"), expr)}
#   SyntaxQuoteNode handles the unquote/unquote-splice form
#     
# create a mechanism for loading .rb and .rst files, and load standard library in rasta on boot

## Using rasta from ruby
# find a way to load stuff written in rasta into ruby
# this requires a method that imports ruby and rasta equivalently

## SOLVING SYMBOL CAPTURE
# make it imposible to use define outside the top scope
# check for un-resolvable Labels before adding a form to defs
# add a namespace property to Labels and qualify them when expanding macros

#(in ,,, (body)) can just create a new environment that simply rebinds self!

# use @ for namespacing?

- can have objects in @head to __apply as message chains (like ioke)

- use modules to mix in __apply behaviours (eg. Chainable...) 

FIND A WAY TO IMPLEMENT SCOPED MONKEY PATCHING... That way you can redefine a type's call method, without having to lose the method sending aspect throughout your code base


CAN REDEFINE AN OBJECT'S EVAL & APPLY METHODS FROM WITHIN THE LANGUAGE!!!!!!!!!!!!!!!!

- char literals

- array/hash access

- add splats

- class special form

- improve error reporting... things should never go wrong silently.
  - when the input is syntactically invalid (eg. unmatching []{}() chars)
  - show short stack trace

- embed repl in vim
  - syntax highlighting (ugh)
  - auto-indent (uuugggghh)
  - when cursor is on a given %, execute cmd sends only that node

let and loop/recur for local vars
(.. obj (method args) (method args))

add better support for sets?
  Set#lispeval should return a proc that acts as a predicate

documentation within the language?

to define a method on an object
(in obj ; instance-eval
  (defn method [a b]...
on a class
(in Array
  (defn ...

; where defn is defined as
defn = proc do |obj, method, fn|
  obj.define_method(method, fn)
end

need to add Object#define_method for that, but that's easy enough

when we want to execute a closure (ie. a special form/macro) in a specific context, we can pass receiver as the first arg to the proc, then the "in" special form does this...

in = proc do |obj, my_proc|
  obj.instance_eval{ my_proc.call(self)} can here, self refers to obj, since it's in an instance_eval
end

then when eval-ing normally (ie. in the root context) we pass the env in as self... that way, we always have full, explicit control over what self refers to in macros and special forms

macro hygeine?
  forced gensyms for locals (how?)
  substitute in special forms and macros (ie. things implemented as procs)

